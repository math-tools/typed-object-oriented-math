============
toomath-core - TODO
============


// ---------- //


==
??  (0.0.0-alpha.18)
==

-------
:break:
-------

[[:api:]]
Types.

    1) ???

const \N : NatSet
fix type Nat : \N.InSet

devient

const Nat : NatSet  car on infère n : Nat dans la def de NatSet


    1) ???
    The notion of set is no longer central, but becomes a type among others.

amo-core/src
├── LICENSE.txt
└── config
    └── type
        ├── about.yaml
        ├── algebra
        │   ├── field
        │   │   ├── ordered
        │   │   │   ├── func
        │   │   │   │   └── ordered.amo
        │   │   │   ├── main.amo
        │   │   │   └── quotient.amo
        │   │   ├── quotient
        │   │   │   ├── func
        │   │   │   │   ├── add-prod.amo
        │   │   │   │   ├── cano-inj.amo
        │   │   │   │   └── equal.amo
        │   │   │   └── main.amo
        │   │   └── std
        │   │       ├── add-prod.amo
        │   │       └── main.amo
        │   ├── group
        │   │   ├── abelian
        │   │   │   ├── add.amo
        │   │   │   ├── main.amo
        │   │   │   └── prod.amo
        │   │   ├── ordered
        │   │   │   └── all.amo
        │   │   ├── semi
        │   │   └── std
        │   │       ├── compo.amo
        │   │       └── main.amo
        │   ├── magma
        │   │   ├── abelian
        │   │   │   ├── add.amo
        │   │   │   ├── main.amo
        │   │   │   └── prod.amo
        │   │   ├── ordered
        │   │   │   ├── main.amo
        │   │   │   └── others.amo
        │   │   └── std
        │   │       ├── compo.amo
        │   │       └── main.amo
        │   ├── monoid
        │   │   ├── abelian
        │   │   │   ├── add.amo
        │   │   │   ├── main.amo
        │   │   │   └── prod.amo
        │   │   ├── ordered
        │   │   │   └── all.amo
        │   │   └── std
        │   │       ├── compo.amo
        │   │       ├── func
        │   │       │   └── op-ntimes.amo
        │   │       └── main.amo
        │   └── ring
        │       ├── abelian
        │       │   ├── add-prod.amo
        │       │   └── main.amo
        │       ├── division
        │       │   ├── add-compo.amo
        │       │   └── main.amo
        │       ├── domain
        │       │   ├── integral
        │       │   │   ├── add-prod.amo
        │       │   │   └── main.amo
        │       │   └── std
        │       │       ├── add-compo.amo
        │       │       └── main.amo
        │       ├── ordered
        │       │   ├── main.amo
        │       │   └── others.amo
        │       ├── semi
        │       └── std
        │           ├── add-compo.amo
        │           └── main.amo
        ├── classical-sets
        │   ├── about.yaml
        │   ├── complex
        │   │   ├── const.amo
        │   │   └── main.amo
        │   ├── decimal
        │   │   ├── const.amo
        │   │   └── main.amo
        │   ├── integer
        │   │   ├── const.amo
        │   │   ├── func
        │   │   │   ├── cano-inj.amo
        │   │   │   ├── div-n-co.amo
        │   │   │   ├── equal.amo
        │   │   │   ├── ordered.amo
        │   │   │   └── sign-n-co.amo
        │   │   └── main.amo
        │   ├── natural
        │   │   ├── const.amo
        │   │   ├── func
        │   │   │   ├── diff-up.amo
        │   │   │   ├── div-n-co.amo
        │   │   │   ├── equal.amo
        │   │   │   └── ordered.amo
        │   │   └── main.amo
        │   ├── rational
        │   │   ├── const.amo
        │   │   ├── func
        │   │   │   └── repr.amo
        │   │   └── main.amo
        │   └── real
        │       ├── const.amo
        │       └── main.amo
        ├── core
        │   ├── about.yaml
        │   ├── boolean
        │   │   ├── const.amo
        │   │   └── func
        │   │       ├── alter-opes.amo
        │   │       └── std-opes.amo
        │   ├── explicit-finite
        │   │   ├── func
        │   │   │   ├── add-elt.amo
        │   │   │   ├── binary-opes.amo
        │   │   │   └── equal.amo
        │   │   └── main.amo
        │   ├── iterate
        │   │   └── func
        │   │       ├── equal-iter.amo
        │   │       ├── image.amo
        │   │       ├── ordered.amo
        │   │       └── set.amo
        │   └── unspec
        │       ├── const.amo
        │       ├── func
        │       │   └── main.amo
        │       └── main.amo
        ├── fundation
        │   ├── multiset
        │   │   ├── finite
        │   │   └── std
        │   │       ├── func
        │   │       │   ├── binary-opes.amo
        │   │       │   └── equal.amo
        │   │       └── main.amo
        │   ├── quotient
        │   │   ├── func
        │   │   │   └── equal.amo
        │   │   └── main.amo
        │   └── set
        │       ├── empty
        │       │   ├── const.amo
        │       │   └── main.amo
        │       ├── finite
        │       ├── ordered
        │       │   ├── func
        │       │   │   ├── std.amo
        │       │   │   └── total.amo
        │       │   ├── std.amo
        │       │   └── total.amo
        │       └── std
        │           ├── func
        │           │   ├── binary-opes.amo
        │           │   └── equal.amo
        │           └── main.amo








> ---------------------------- <

New ''DecSet'', ''Dec'' and ''\D'' \objs build under the rational-like types (that simplifies the implementation).

    --> besoin de sous-anneau pour ne pas tout redéfinir, du coup aussi sous corps , sous groupe



> ---------------------------- <

f : Complex -> Complex  vs f : \C -> \C   bien pour expliquer au passage que l'on raisonne sur des types et non des ens memem si on émule ce type d'obj

> ---------------------------- <

Parse pour x - y , x / y , - x , x~(inv mult) et x**m mais aussi m x pour mtimes

    --> maj des specs pour natset et audessus !


> ---------------------------- <

NatPrimeSet : def axiom puis \P


> ---------------------------- <

passer de id a neutral et garder id fonc identité !!!


> ---------------------------- <

ttes les fuoncs implemntees doivent etre contractualisé pour un type ou un contexte !!! Chiant mais obligatoire !

    --> faire au cas par cas !


> ---------------------------- <

about.yaml


> ---------------------------- <

doc

    --> indiquer idée de def constructive un maximum et quand impossible, idée de pouvoir donner une indication : du coup R via ordre complet est mieux que via Dedekin ou Cauchy


> ---------------------------- <

    1) New types.

        + The real field ?????
             penser à inj_rat

        + The complex field via RealSet * RealSet : easy!
             penser àinj_real

        + The hamiltonian field via ComplSet * ComplSet : easy!
             penser inj_compl (utile pour de la geo 3d, du coup pas les octonions en std)

        + geometry : voir GEoCoq

        + polynome

        + analyse ???

        + analyse ???

        + Semigroup and semiring ==> group et ring

> ---------------------------- <

    1) OederedSet

        ---> compléter bon ordre ou autre ???


> ---------------------------- <

    1) Finite sets or multisets qui sont std mais avec une bijection vers ExplicitFiniteSet ???


> ---------------------------- <

tech doc à reprendre !!!!

    ---> les preuves passent dans la doc classique dans la section de toutes les psecs : par exemple, on affiche le code brutalement des specs sans commentaiers (ok car on bosse sur petits fichiers), puis on explique tel ou tel point

    ---> on utilise tnsdoc directement !!!


> ---------------------------- <

doc

    --> indiquer que ce proj sera utilisé pour un idco technique lisible par un humain (avec au passage la possibilité de débsuquer des erreurs par d'autres)

    --> faire des exemples pour la syntaxique

    -> section dédié à l'ensemble des defs !


> ---------------------------- <

+ - * / o : ordre de préécdence imposé mais modifiable !!!

    ---> Comment ? Faore truc flexible ou non ? syst d'api pulique et d'API lourde mais utilisée en interne


> ---------------------------- <

On passe via yaml de config transposable en json, BdD (No) SQL facilment (forunis les outis=ils)

    description
    arités multipls (cf int formerlle vs entre deux borns)
    signatures diff pour dire d'où on part et ou on arrive
    propriété vérifié : penser à sous-classe (par ex, integral linaire en la fonction, chasles sur les borens...)

Ces def yaml servent de base pour les paresuers, ou autres outilsun YAML de doc qui donne les clés obligatoires, celles multipls...etcpenser à proposer y

> ---------------------------- <


program lang

    for_toks_explicit_list

    Inductive list (A:Type) : Unspec :=
        | nil : list A
        | cons : A -> list A -> list A.


    sort : ∀ (l : list nat), {l' : list nat | sorted l' /\ same_elements l l'}




> ---------------------------- <

    1) New directive: ''func_ext'' allows to use very closed implementations for different \signs of one \func.

        + Suppose that ''func succ (n : \N) -> \N {return (\N.succ n)}''.

        + Then, use ''func_ext succ ((n : \N) -> \N) ((n : \Z) -> \Z) with "\Z" for "\N''.

        + Doing that, we have defined ''func succ (n : \Z) -> \Z {return (\Z.succ n)}'' (the ''with'' part is for stupid, but useful, replacements inside the ''{ ... }'' block).
