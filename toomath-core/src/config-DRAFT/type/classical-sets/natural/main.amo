/***
===============
Natural \nb set
===============

-------------
\Gene \struct
-------------

A natural \nbs like set is an "add" monoid with an additional binary
"prod" \ope respecting the Peano axioms with the more precise
''succ_iter_zero_is_N'' axiom instead of the "predecessor" and the
inductive axioms suchas to know that any element of ''N'' becomes
from a finite \nb of successive applications of the ''succ'' function
on ''zero''.


note::
    ''forall x in N , x!= 0 ==> (exist x_pr in N , x = succ x_pr)''
    is the "predecessor" axiom . We don't use it because it allows
    the existence of non-\std natural sets, without the "induction"
    axiom, whereas the code ''elt in (iter_set succ zero)'' for the
    special in function avoids non-\std natural sets and gives the
    induction principle.
***/

type NatSet : Set as N {
  const zero : N.InSet

  with (x y : N.InSet) in
  parse "{x} + {y}" as (add x y)  ,
        "{x} * {y}" as (prod x y)

  func succ : N -> N      ,
       add  : N -> N -> N ,
       prod : N -> N -> N ,
       lt   : N -> N -> N

  const NonZeroSet := (diff N {: zero :})


  fix func in (elt : Unspec) -> \B {
    return (elt in (iter_set succ zero))
  }

  axiom {
    zero_min :=
      forall x in N ,
      zero != succ x

    succ_injective :=
      forall x y in N ,
      succ x = succ y ==> x = y

    add_induc_def :=
      forall x y in N ,
      succ (x + y) = x + (succ y)

    zero_absorbent :=
      forall x in N ,
      zero * x = zero

    prod_induc_def :=
      forall x y in N ,
      x * (succ y) = (x * y) + x
  }


  type_ext N : TotalOrderedMonoidAdd {
    var zero := N.zero

    func op  := N.add ,
         lt  := N.lt  ,
         lte := N.lte
  }
}
