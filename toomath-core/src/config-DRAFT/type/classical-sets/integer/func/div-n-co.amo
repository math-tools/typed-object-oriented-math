/***
--------------------------
Euclidean \div and its use
--------------------------

We implement the following \funcs.

    1) Euclidean \div.

    1) Just the quotient of an euclidean \div.

    1) Just the remainder of an euclidean \div.

    1) gcd' and lcm' of two \nats.


note::
    For the implementation of the euclidean \div, look at the user
    friendly \doc.
***/

with (Z : Z.InSetSet , N : N.InSetSet) in {
  fix func div (a : Z.InSet)
            -> (b : Z.NonZeroSet.InSet)
            -> (Z.InSet * Z.InSet)
  {
// Let's work in ''NatSet''.
    var (_q_abs , _r_abs) := div (cano_inj_to_nat (abs a))
                                 (cano_inj_to_nat (abs b))

// Let's go back into ''IntSet'' (we haevn't any dynamic subtyping).
    var q_sign := (sign b) * (cano_inj _q_abs),
        r_abs  := cano_inj _r_abs

    return (
      match (sign a , r_abs) with
        | (minus_one , zero) -> (oppo q_sign , r_abs)
        | (minus_one , _   ) -> (succ (oppo q_sign) , (oppo b) + (oppo r_abs))
        | _                  -> (q_sign , r_abs)
    )
  }


  fix func quot (a : Z.InSet)
             -> (b : Z.NonZeroSet.InSet)
             -> Z.InSet
  {
    var (q , _) := (div a b)

    return q
  }


  fix func rem (a : Z.InSet)
            -> (b : Z.NonZeroSet.InSet)
            -> Z.InSet
  {
    var (_ , r) := (div a b)

    return r
  }


  fix func gcd (a : Z.NonZeroSet.InSet)
            -> (b : Z.NonZeroSet.InSet)
            -> Z.InSet
  {
    return (
      cano_inj (
        gcd (cano_inj_to_nat (abs a))
            (cano_inj_to_nat (abs b))
      )
    )
  }


  fix func lcm (a : Z.NonZeroSet.InSet)
            -> (b : Z.NonZeroSet.InSet)
            -> Z.InSet
  {
    return (
      cano_inj (
        lcm (cano_inj_to_nat (abs a))
            (cano_inj_to_nat (abs b))
      )
  }
}
