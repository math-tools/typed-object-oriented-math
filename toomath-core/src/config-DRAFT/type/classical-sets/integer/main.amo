/***
================
\int \nb sets
================

-------------
\Gene \struct
-------------

A \int \nbs like set is an "add-prod" ring respecting some "succ-pred"
axioms mixed with some "pos-neg partition" axioms (we could have used the
classical quotient construction from pairs of naturals, but this choice not
reflects the "pred-succ chain" relation between two \ints).
***/

type IntSet : DomainAddProd as Z {
  var zero : Z.InSet

  func succ     : Z -> Z             ,
       pred     : Z -> Z             ,
       add      : Z -> Z -> Z        ,
       prod     : Z -> Z -> Z        ,
       oppo     : Z -> Z             ,
       lt       : Z -> Z -> \B       ,
       cano_inj : NatSet.InSet -> Z.InSet

  with (x y : Z.InSet) in
  parse "{x} + {y}" as (add x y)  ,
        "{x} * {y}" as (prod x y)

  const PosSet     := iter_set_ns succ zero     ,
        NegSet     := iter_set_ns pred zero     ,
        NonPosSet  := (union NegSet {: zero :}) ,
        NonNegSet  := (union PosSet {: zero :}) ,
        NonZeroSet := (union PosSet NegSet)

  var one       := succ zero ,
      minus_one := pred zero

  fix func in (elt : Unspec) -> \B {
    return (
      elt = zero
      or
      elt in NonZeroSet
    )
  }

  axiom {
    // pred and succ
    succ_injective :=
      forall x y in Z ,
      succ x = succ y ==> x = y

    pred_vs_succ :=
      forall x in Z ,
      succ (pred x) = x

    // add and prod
    add_induc_def :=
      forall x y in Z ,
      succ (x + y) = x + (succ y)

    zero_absorbent :=
      forall x in Z ,
      zero * x = zero

    prod_induc_def :=
      forall x y in Z ,
      x * (succ y) = (x * y) + x
  }


  type_ext IntSet : TotalOrderedDomainAddProd {
    var id_add  := Z.zero ,
        id_prod := Z.InSet

    func op_add  := Z.add  ,
         inv_add := Z.oppo ,
         op_prod := Z.prod ,
         lt      := Z.lt
  }
}
