/***
------------------------------
Classical binary \opes on sets
------------------------------

We implement the following \opes.

  1) Intersection.

  1) Difference.

  1) Product.

  1) Union and disjunct union.
***/

fix func inter (set_1 : Set | ExplicitFiniteSet)
            -> (set_2 : Set | ExplicitFiniteSet)
            -> Set
{
  var inter_set : Set

  fix func diff_set.in (elt : Unspec) -> \B {
    return (elt in set_1 and elt in set_2)
  }

  return inter_set
}


fix func diff (set_1 : Set | ExplicitFiniteSet)
           -> (set_2 : Set | ExplicitFiniteSet)
           -> Set
{
  var diff_set : Set

  fix func diff_set.in (elt : Unspec) -> \B {
    return (elt in set_1 and not (elt in set_2))
  }

  return diff_set
}


fix func union (set_1 : Set | ExplicitFiniteSet)
            -> (set_2 : Set | ExplicitFiniteSet)
            -> Set
{
  var union_set : Set

  fix func union_set.in (elt : Unspec) -> \B {
    return (elt in set_1 or elt in set_2)
  }

  return union_set
}


fix func disj_union (set_1 : Set | ExplicitFiniteSet)
                 -> (set_2 : Set | ExplicitFiniteSet)
                 -> Set
{
  var disj_union_set : Set         ,
      InSet_1        : set_1.InSet ,
      InSet_2        : set_2.InSet

// WARNING!
// ''func disj_union_set.in (elt : Unspec, deco: SymbType) -> \B''
// can't be used because the ''in'' function must accept any
// "single" object.
  fix func disj_union_set.in (elt : Unspec) -> \B {
    if not (is_pair elt)  {
      return false
    } {
      var (e , deco) := elt

      if not deco in {: symb_1 , symb_2 :} {
        return false
      }{
        return (
          if (deco = symb_1) (e in set_1) (e in set_2)
        )
      }
    }
  }

  fix func disj_union_set.inj_1 (elt : InSet_1) -> (InSet_1, SymbType) {
    return (elt, symb_1)
  }

  fix func disj_union_set.inj_2 (elt : InSet_2) -> (InSet_1, SymbType) {
    return (elt, symb_2)
  }

  return disj_union_set
}


with (E F : Set | ExplicitFiniteSet) in
parse "{E} * {F}" as (prod E F)

fix func prod (set_1 : Set | ExplicitFiniteSet)
           -> (set_2 : Set | ExplicitFiniteSet)
           -> Set
{
  var prod_set : Set

  fix func prod_set.in (elt : Unspec) -> \B {
    if not (is_pair elt)  {
      return false
    } {
      var (e_1 , e_2) := elt

      return (e_1 in set_1 and e_2 in set_2)
    }
  }

  return prod_set
}
