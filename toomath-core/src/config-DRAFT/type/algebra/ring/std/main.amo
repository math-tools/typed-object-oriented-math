/***
====
Ring
====

-------------
\Gene \struct
-------------

A ring ''R'' is a set with two binary \opes ''R.op_add'' and
''R.op_prod'' verfiying the following properties.

    1) ''R.op_add'' defines an abelian group \struct with ''R.id_add''
    as neutral element.

    2) ''R.op_prod'' defines a monoid \struct with ''R.id_prod'' as neutral
    element.

    3) ''R.op_add'' and ''R.op_prod'' verify two distribution laws, one on
    the left and the other on the right, as do addition and multiplication
    on natural \nbs.

    4) The identities for ''R.op_add'' and ''R.op_prod'' are different.
***/

type Ring : Set as R {
  var id_add  : R.InSet ,
      id_prod : R.InSet

  func op_add  : R -> R -> R ,
       inv_add : R -> R      ,
       op_prod : R -> R -> R

// "Non zero set" is useful, contratry to the "non unit set".
  const NonZeroSet := (diff R {: id_add :})

// Axioms for "(R.op_add, R.id_add)'' being an abelian group.
  var GrpOpAdd : Set

  type_ext GrpOpAdd : GroupAbelian {
    var id  := id_add

    func op  := op_add  ,
         inv := inv_add
  }

// Axioms "(R.op_prod, R.id_prod)'' being a monoid.
  var MonoOpProd : Set

  type_ext MonoidProd : Monoid {
    var id := id_prod ,
        op := op_prod
  }

// New axioms.
  axiom {
    two_neutral_elts :=
      id_add != id_prod

    left_distrib :=
      forall x y z in R ,
      op_prod x (op_add y z) = op_add (op_prod x y) (op_prod x z)

    right_distrib :=
      forall x y z in R ,
      op_prod (op_add x y) z = op_add (op_prod x z) (op_prod y z)
  }

  fix func add_ntimes (x : R.InSet)
                   -> (nb : Nat)
                   -> R.InSet
  {
    (iter_ntimes op_add id_add x nb)
  }

  fix func prod_ntimes (x : R.InSet)
                    -> (nb : Nat)
                    -> R.InSet
  {
    (iter_ntimes op_prod id_prod x nb)
  }
}
