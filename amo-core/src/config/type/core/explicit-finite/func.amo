/***
???
 on doit construire les versions {: ... :} sinon rien de plus
***/

fix fun add (elt : Untyped) (efset : ExplicitFiniteSet) -> ExplicitFiniteSet {
  if (elt in efset) {
    return efset
  } {
    return (
      match efset
        | {: old_elts :} -> {: elt || old_elts :}
    )
  }
}


fix func diff (efset_1 : ExplicitFiniteSet)
           -> (efset_2 : ExplicitFiniteSet)
           -> ExplicitFiniteSet
{
  var diff_efset : ExplicitFiniteSet := {::}

  for_toks_explicit_set efset_1 tok_elt {
    if not (tok_elt in efset_2) {
      add tok_elt diff_efset
    } {}
  }

  return diff_efset
}


fix func union (efset_1 : ExplicitFiniteSet)
            -> (efset_2 : ExplicitFiniteSet)
            -> ExplicitFiniteSet
{
  var union_efset := efset_1

  for_toks_explicit_set efset_2 tok_elt_2 {
    if not (tok_elt_2 in union_efset) {
      add tok_elt_2 union_efset
    } {}
  }

  return union_efset
}


fix func disj_union (efset_1 : ExplicitFiniteSet)
                 -> (efset_2 : ExplicitFiniteSet)
                 -> ExplicitFiniteSet
{
  var disj_union_efset : ExplicitFiniteSet := {::} ,
      InEFSet_1        : efset_1.InSet             ,
      InEFSet_2        : efset_2.InSet

  for_toks_explicit_set efset_1 tok_elt {
    add (tok_elt, symb_1) disj_union_efset
  }

  for_toks_explicit_set efset_2 tok_elt {
    add (tok_elt, symb_2) disj_union_efset
  }

  fix func disj_union_efset.inj_1 (elt : InEFSet_1) -> (InEFSet_1, SymbType) {
    return (elt, symb_1)
  }

  fix func disj_union_efset.inj_2 (elt : InEFSet_2) -> (InEFSet_2, SymbType) {
    return (elt, symb_2)
  }

  return disj_union_efset
}


fix func prod (efset_1 : ExplicitFiniteSet)
           -> (efset_2 : ExplicitFiniteSet)
           -> ExplicitFiniteSet
{
  var prod_efset : ExplicitFiniteSet := {::}

  for_toks_explicit_set efset_1 tok_elt_1 {
    for_toks_explicit_set efset_2 tok_elt_2 {
      add (tok_elt_1, tok_elt_2) prod_efset
    }
  }

  return prod_efset
}
